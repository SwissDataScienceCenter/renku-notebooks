from abc import ABC, abstractmethod


class GenericErrorBase(ABC):
    """Other than Werkzeug and Marshmallow validation errors,
    the notebook service expects all other errors raised should
    follow this abstract class."""

    @property
    @abstractmethod
    def status_code(self) -> int:
        pass

    @property
    @abstractmethod
    def message(self) -> str:
        pass

    @property
    @abstractmethod
    def code(self) -> int:
        pass

    @property
    @abstractmethod
    def detail(self) -> str:
        pass


class GenericError(GenericErrorBase, Exception):
    """A generic error class that is the parent class of all API errors raised
    by the notebook service code."""

    def __init__(
        self, message="Something went wrong.", status_code=500, code=2000, detail=None
    ):
        self._message = message
        self._status_code = status_code
        self._code = code
        self._detail = detail

    @property
    def message(self):
        return self._message

    @property
    def status_code(self):
        return self._status_code

    @property
    def code(self):
        return self._code

    @property
    def detail(self):
        return self._detail


class UserInputError(GenericError):
    """
    *Error codes: from 1000 to 1999*

    This category includes all the errors generated by user input. There is no unexpected
    error nor bugs here. The user should be able to address these issues.
    An example could be a wrong parameter (E.G. trying to access a non-existing repository,
    or a private repository without proper permissions).
    """

    def __init__(
        self, message="Invalid user input.", status_code=422, code=1000, detail=None
    ):
        self._message = message
        self._status_code = status_code
        self._code = code
        self._detail = detail


class ProgrammingError(GenericError):
    """
    *Error codes: from 2000 to 2999*

    The programming errors are bugs or unexpected cases. In the first case, they should lead
    to creating a new GitHub issue; in the latter, it may be necessary to handle the specific
    error to provide the user a precise explanation.
    """

    def __init__(
        self, message="You have found a bug.", status_code=500, code=2000, detail=None
    ):
        self._message = message
        self._status_code = status_code
        self._code = code
        self._detail = detail


class IntermittentError(GenericError):
    """
    *Error codes: from 3000 to 3999*

    This category includes errors that may temporarily affect the user, but they don't depend
    on a wrong input and can be classified as a bug. Repeating the same action after some
    time should be enough to solve the problem.
    An example could be a temporarily unavailable backend service (E.G. the GitLab instance)
    or a transient network problem.
    """

    def __init__(
        self,
        message="We seem to be having some issues, please try again later.",
        status_code=500,
        code=3000,
        detail=None,
    ):
        self._message = message
        self._status_code = status_code
        self._code = code
        self._detail = detail


class MissingResourceError(UserInputError):
    """A specific subclass of UserInputError that results when
    the user requests a resource that does not exist."""

    def __init__(
        self,
        message="The resource you are requesting or is needed for your request does not exist.",
        code=1404,
        detail=None,
    ):
        self._message = message
        self._status_code = 404
        self._code = code
        self._detail = detail
